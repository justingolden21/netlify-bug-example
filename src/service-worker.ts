/**
 * Service Worker
 *
 * Handles installing offline, updating, caching, and fetching PWA
 *
 * Current service worker is made to just store data offline in first install
 * (including pages user hasn't visited) and update immediately
 *
 * @link https://kit.svelte.dev/docs/service-workers
 */

/**
 * Service Worker Lore:
 *
 * At some point, sw stopped working and won't serve users latest version
 * May or may not be caused by update banner code
 * Replacing with a simple service worker to ensure users get updates
 * Leaving `isMajorChange.ts`, `updates.ts`, and `checkVersion` in `+layout.ts`
 * and commented code in this file below as well
 * in case we want to restore this functionality in the future.
 */

/**
 * No-op Service Worker
 *
 * In case of emergency, break glass
 * @link https://developer.chrome.com/docs/workbox/remove-buggy-service-workers/
 */

/*
self.addEventListener('install', () => {
	// Skip over the "waiting" lifecycle state, to ensure that our
	// new service worker is activated immediately, even if there's
	// another tab open controlled by our older service worker code.
	self.skipWaiting();
});

self.addEventListener('activate', () => {
	// Optional: Get a list of all the current open windows/tabs under
	// our service worker's control, and force them to reload.
	// This can "unbreak" any open windows/tabs as soon as the new
	// service worker activates, rather than users having to manually reload.
	self.clients
		.matchAll({
			type: 'window'
		})
		.then((windowClients) => {
			windowClients.forEach((windowClient) => {
				windowClient.navigate(windowClient.url);
			});
		});
});

// End no-op service worker
*/

/**
 * Old Service Worker
 *
 * This was used for a while but was either not working offline or not getting updates
 */

/*

/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />
import { build, files, version } from '$service-worker';

// For TypeScript
declare const self: ServiceWorkerGlobalScope;
const sw: ServiceWorkerGlobalScope = self;

// Unique cache name
const CACHE = `cache${version}`;

// Routes to cache
const routes = [
	'/',
	'/worldclock',
	'/stopwatch',
	'/more',
	'/pomodoro',
	'/chessclock',
	'/sunrisesunset',
	'/rubikscube',
	'/changelog'
];

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static/` directory
const ASSETS = [...build, ...files, ...routes];

// let gotVersion = false;

// sw.addEventListener(
// 	'message',
// 	({ data: message }) => message === 'SKIP_WAITING' && sw.skipWaiting()
// );

sw.addEventListener('install', (event) => {
	async function addFilesToCache() {
		// Commenting out below as currently seems to break sw update logic:

		// // broadcast version to window
		// const versionChannel = new BroadcastChannel('versionChannel');

		// versionChannel.addEventListener(
		// 	'message',
		// 	({ data: message }) => (gotVersion = message === 'GOT_VERSION')
		// );

		// // run until the client receives version
		// while (!gotVersion) {
		// 	// @ts-ignore: `__version__` exists globally
		// 	versionChannel.postMessage('VERSION:' + __version__);
		// 	await new Promise((resolve) => setTimeout(resolve, 100));
		// }

		// Create new cache and add all files to it
		const cache = await caches.open(CACHE);
		await cache.addAll(ASSETS);
	}
	event.waitUntil(addFilesToCache());
});

sw.addEventListener('activate', (event) => {
	// Remove previous cached data from disk
	async function deleteOldCaches() {
		for (const key of await caches.keys()) {
			if (key !== CACHE) await caches.delete(key);
		}
	}
	event.waitUntil(deleteOldCaches());
});

sw.addEventListener('fetch', (event) => {
	// ignore POST requests etc
	if (event.request.method !== 'GET') return;

	async function respond() {
		const url = new URL(event.request.url);
		const cache = await caches.open(CACHE);

		// `build`/`files` can always be served from the cache
		if (ASSETS.includes(url.pathname)) {
			return cache.match(url.pathname);
		}

		// for everything else, try the network first, but
		// fall back to the cache if we're offline
		try {
			const response = await fetch(event.request);

			if (response.status === 200) {
				cache.put(event.request, response.clone());
			}

			return response;
		} catch {
			return cache.match(event.request);
		}
	}

	event.respondWith(respond());
});

*/

/**
 * Current Service Worker
 *
 * Caches all pages and assets for offline upon install and updates in the background
 * Thanks ChatGPT
 */

/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

import { build, files, version } from '$service-worker';

// For TypeScript
declare const self: ServiceWorkerGlobalScope;

const CACHE_NAME = `cache${version}`;

// Routes to cache
const routes = [
	'/',
	'/birthdays',
	'/calendar',
	'/chessclock',
	'/countdown',
	'/pictureinpicture',
	'/pomodoro',
	'/rubikscube',
	'/stopwatch',
	'/sunrisesunset',
	'/timer',
	'/timestamp',
	'/weather',
	'/worldclock',

	'/about',
	'/changelog',
	'/more',

	'about/birthdays',
	'about/calendar',
	'about/chessclock',
	'about/clock',
	'about/countdown',
	'about/pictureinpicture',
	'about/pomodoro',
	'about/rubikscube',
	'about/stopwatch',
	'about/sunrisesunset',
	'about/timer',
	'about/timestamp',
	'about/weather',
	'about/worldclock',
	'about/app',
	'about/dates',
	'about/goals',
	'about/time'
];

// `build` is an array of all the files generated by the bundler,
// `files` is an array of everything in the `static/` directory
const urlsToCache = [...build, ...files, ...routes];

// Prevent cachine in development, so live reload works
const isDev = !import.meta.env.PROD;

// Install - cache assets during install
self.addEventListener('install', (event) => {
	// In development, skip waiting and don't cache anything
	if (isDev) {
		self.skipWaiting();
		return;
	}

	// `waitUntil` ensures `install` event doesn't complete until cache is populated
	// `skipWaiting` after caching to immediately activate new service worker
	event.waitUntil(
		caches
			.open(CACHE_NAME)
			.then((cache) => cache.addAll(urlsToCache))
			.then(() => self.skipWaiting())
	);
});

// Fetch - serve cached content when available, else fetch from network
self.addEventListener('fetch', (event) => {
	// In development, always fetch from network
	if (isDev) {
		return;
	}

	// Ignore POST requests etc.
	if (event.request.method !== 'GET') return;

	// Confirm request URL starts with http or https (ignore browser extension requests)
	if (!new URL(event.request.url).protocol.startsWith('http')) return;

	event.respondWith(
		caches.match(event.request).then((response) => {
			// Cache hit - return response
			if (response) {
				return response;
			}

			// Request is not in cache, so we fetch from the network
			// Clone the request because it's a stream
			const fetchRequest = event.request.clone();

			return fetch(fetchRequest).then((response) => {
				// Check response is valid
				if (!response || response.status !== 200 || response.type !== 'basic') {
					return response;
				}

				// Clone the response because it's a stream
				const responseToCache = response.clone();

				// Open cache and put fetched response in cache
				event.waitUntil(
					caches.open(CACHE_NAME).then((cache) => cache.put(event.request, responseToCache))
				);

				return response;
			});
		})
	);
});

// Activate - clean up old caches when a new service worker activates
self.addEventListener('activate', (event) => {
	// Caches to keep
	const cacheWhitelist = [CACHE_NAME];

	// `waitUntil` ensures `activate` event doesn't complete until old caches are cleaned up
	// `self.clients.claim` to take control of all clients immediately, without need for hard refresh
	event.waitUntil(
		caches
			.keys()
			.then((cacheNames) => {
				return Promise.all(
					cacheNames.map((cacheName) => {
						// Delete caches that aren't in whitelist
						if (cacheWhitelist.indexOf(cacheName) === -1) {
							return caches.delete(cacheName);
						}
					})
				);
			})
			.then(() => self.clients.claim())
	);
});
